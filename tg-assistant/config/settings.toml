# =============================================================================
# Telegram Personal Assistant - Configuration
# =============================================================================
#
# Deploy to: /etc/tg-assistant/settings.toml (production)
#            ./config/settings.toml (development)
#
# SECURITY NOTES:
# - This file contains NO secrets. All credentials live in the system keychain
#   or are injected via systemd LoadCredential at runtime.
# - Placeholder values (CHANGE_ME, YOUR_*) must be replaced before deployment.
# - The settings.toml is mounted read-only into service containers via systemd
#   ReadOnlyPaths=/etc/tg-assistant.

# =============================================================================
# DATABASE
# =============================================================================
[database]
# PostgreSQL connection string. Uses pgvector extension for embedding search.
# The actual password is injected at runtime from the system keychain --
# this URL uses a placeholder that the application replaces on startup.
#
# Production: uses peer authentication (Unix socket) so no password in URL.
# Each service connects with its own DB role (syncer_role / querybot_role).
url = "postgresql://localhost:5432/tg_assistant"

# Connection pool size. Keep low on Raspberry Pi to conserve memory.
# The syncer needs fewer connections (mostly sequential writes).
# The querybot may need a few more for concurrent search + audit writes.
pool_size = 5

# =============================================================================
# SYNCER (Telethon / MTProto User API)
# =============================================================================
[syncer]
# Telegram API credentials -- obtain from https://my.telegram.org/apps
# SECURITY: These are placeholders. The real values are stored in the system
# keychain and injected via environment variables at runtime by systemd.
# They appear here only for schema documentation and local development.
api_id = "YOUR_API_ID"       # Integer, but stored as string for TOML compat
api_hash = "YOUR_API_HASH"   # 32-character hex string

# Path to the encrypted Telethon .session file.
# CRITICAL: A stolen session file grants FULL account access (read, write,
# delete, change settings). This is why we encrypt it and restrict access
# to the tg-syncer user only (0600 permissions).
session_path = "/var/lib/tg-syncer/.telethon/tg-assistant.session"

# How often to poll for new messages (seconds).
# Lower = more responsive but higher risk of rate limiting.
# Telegram's MTProto rate limits are stricter than Bot API -- we must
# behave like a normal client, not a scraper.
sync_interval_seconds = 30

# Minimum delay between consecutive API calls (seconds).
# Prevents triggering Telegram's FloodWaitError. If FloodWait is received,
# the syncer backs off automatically using Telethon's built-in handler,
# but this baseline rate limit avoids hitting it in the first place.
rate_limit_seconds = 2

# Maximum messages to fetch per sync cycle per dialog.
# Keeps each sync cycle bounded to avoid long-running API sessions
# and excessive memory use on the Pi.
batch_size = 100

# How far back to fetch messages on the FIRST sync of a chat (days).
# Once a chat has been synced, subsequent passes use the last synced
# message ID and this limit no longer applies.
# Set to 0 to disable the limit and fetch all history.
max_history_days = 365

# Encrypt the Telethon session file at rest using Fernet (AES-128-CBC + HMAC).
# The encryption key is stored in the system keychain, never on disk.
# Even if the session file is stolen, it's useless without the key.
encrypted_session = true

# Read-only method allowlist for the Telethon client wrapper.
# SECURITY: This is an ALLOWLIST, not a blocklist. Any method not listed
# here is BLOCKED BY DEFAULT. New Telethon methods added in updates are
# automatically blocked until explicitly reviewed and added.
#
# This is the innermost layer of read-only enforcement:
#   Layer 1: nftables (kernel) -- only Telegram IPs reachable
#   Layer 2: systemd (process) -- hardened sandbox
#   Layer 3: This allowlist (application) -- only read methods callable
[syncer.read_only]
allowed_methods = [
    # Dialog/chat enumeration
    "get_dialogs",
    "iter_dialogs",

    # Message retrieval (the core sync functionality)
    "get_messages",
    "iter_messages",

    # Entity resolution (needed to map IDs to names)
    "get_entity",

    # Participant info (for group context)
    "get_participants",

    # Self-identification
    "get_me",

    # Profile photo download (for UI, optional)
    "download_profile_photo",

    # Connection lifecycle (required for operation)
    "connect",
    "disconnect",
    "is_connected",
]

# =============================================================================
# QUERY BOT (python-telegram-bot / Bot API + Claude)
# =============================================================================
[querybot]
# The bot token is stored in the system keychain, not here.
# This key tells the application which keychain entry to look up.
bot_token_keychain_key = "tg-assistant-bot-token"

# SECURITY: Only respond to this Telegram user ID. All other messages are
# silently dropped (not even an error response, to avoid information leakage).
# Find your ID: message @userinfobot on Telegram.
owner_telegram_id = OWNER_ID_PLACEHOLDER  # Replaced by setup.sh with your Telegram user ID

# Rate limiting to prevent API cost runaway and abuse.
# 20 queries/minute is generous for personal use; adjust down if concerned
# about Claude API costs.
max_queries_per_minute = 20

# Maximum number of context messages to send to Claude per query.
# More context = better answers but higher token cost and latency.
# 50 messages is a good balance for summarization tasks.
max_context_messages = 50

# Claude API configuration
[querybot.claude]
# Model selection. Claude Sonnet 4.5 balances quality, speed, and cost.
# For complex analysis, consider upgrading to claude-opus-4-20250514.
model = "claude-sonnet-4-5-20250929"

# Maximum tokens in Claude's response. 4096 is sufficient for summaries
# and analysis; increase for very long conversation reconstructions.
max_tokens = 4096

# Temperature controls randomness. Lower = more deterministic/factual.
# 0.3 is good for factual retrieval and summarization tasks.
# Avoid 0.0 (can cause repetition) or >0.7 (too creative for search).
temperature = 0.3

# Claude API key is stored in the system keychain.
api_key_keychain_key = "tg-assistant-claude-api-key"

# =============================================================================
# EMBEDDINGS
# =============================================================================
[embeddings]
# Embedding provider for semantic search.
# "local" = sentence-transformers running on-device (no API call needed)
provider = "local"

# Local model -- all-MiniLM-L6-v2 runs well on Pi's ARM64.
local_model = "all-MiniLM-L6-v2"
local_dimensions = 384

# =============================================================================
# SECURITY
# =============================================================================
[security]
# Full audit logging for security review and incident forensics.
# Every API call, every query, every rate limit hit is logged.
enable_audit_log = true

# Audit log location. This directory must be writable by both service users.
# The systemd services grant ReadWritePaths to this directory.
# Consider log rotation via logrotate (see scripts/setup-raspberry-pi.sh).
log_file = "/var/log/tg-assistant/audit.log"

# Encrypt the Telethon session at rest using Fernet symmetric encryption.
# The encryption key lives in the system keychain, never on disk.
# This protects against session theft via filesystem access.
session_encryption = true

# System keychain service name. All secrets are stored under this service
# in the OS keychain (libsecret on Linux, Keychain on macOS).
# Keys stored: bot token, Claude API key, session encryption key.
keychain_service = "tg-assistant"

# Prompt injection detection. Log and flag messages that match known
# injection patterns. These are still synced (for completeness) but flagged
# in the database so Claude can be warned about them.
detect_prompt_injection = true

# Maximum length (characters) for user query messages.
# Messages exceeding this limit are rejected before entering the pipeline.
max_input_length = 4000

# Maximum log age before rotation (days).
max_log_age_days = 30

# Maximum log file size before rotation (megabytes).
max_log_size_mb = 100

# =============================================================================
# RESOURCE LIMITS (Optimized for Raspberry Pi 4/5)
# =============================================================================
[resources]
# Memory limits per service. These are enforced by systemd MemoryMax
# and also checked at the application level as a safety net.
#
# Pi 4 (4GB): syncer=256M + querybot=512M + postgres=512M + OS = ~2.5GB
# This leaves headroom for OS caches and other processes.
syncer_max_memory_mb = 256
querybot_max_memory_mb = 512

# Maximum concurrent operations.
# Syncer: 2 concurrent dialogs being synced (sequential is safer for rate limits)
# Querybot: 2 concurrent queries (only one user, but allows overlap)
max_concurrent_sync_jobs = 2
max_concurrent_queries = 2

# Execution timeout for individual operations (seconds).
# Prevents runaway processes from consuming resources indefinitely.
max_sync_timeout_seconds = 120
max_query_timeout_seconds = 60

# CPU quota (percentage). Enforced by systemd CPUQuota.
# Keeps the Pi responsive for SSH and other management tasks.
syncer_cpu_quota_percent = 50
querybot_cpu_quota_percent = 60
